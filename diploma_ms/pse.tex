В настоящее время существует множество \textit{проблемно-моделирующих сред} (англ. \textit{problem solving environment}),
способных решать широкий спектр задач гидрогазодинамики.
Под ПМС понимается специализированное программное обеспечение для решения определённого класса задач,
сочетающее в себе автоматизированные вычислительные методы и пользовательский интерфейс для управления ходом решения поставленной задачи.
В качестве вычислительного метода обычно используются или численное решение уравне­ния Навье"--~Стокса
или статистическое моделирование кинетического уравнения Больцмана (метод DSMC).
Также применяются модельные уравнения, дающие верную качественную оценку только для близким к равновесным процессам.
Область явлений, для которой число Кнудсена (отношение длины свободного пробега к характерному размеру обтекаемый тел) порядка единицы,
вызывают большие сложности. Эта область наиболее характерна для моделирования газа в МЭМС и
включает в себя широкий круг явлений от теплового скольжения до затухания ударных волн. 
Для решения этой проблемы использован описанный выше консервативный метод точного решения кинетического уравнения Больцмана,
который лёг в основу разработанной ПМС.

Для достижения поставленной цели с использованием открытых технологий был написан кроссплатформенный программный код,
позволяющий эффективно выполнять расчёты как на персональном компьютере, так и на многопроцессорных кластерах.
В качестве языка программирования был выбран C++, совмещающий высокое быстродействие с объектно-ориентированным программированием,
что немаловажно для дальнейшего перспективного развития ПМС. 
Благодаря универсальности метода область решаемых задач не ограничивается описанной,
а гибкость реализации ПМС позволяет применять его не только для академических расчётов,
но и в промышленных целях для моделирования сложных конструкций.

\subsection{Общая структура}

На рис.~\ref{fig:pse} представлена схема потока данных от входных параметров, предоставляемых пользователем,
и генерации расчётной сетки до визуализации результатов с использованием специализированных пакетов.
Центральное место на рисунке занимает \textit{солвер} (или решатель) "--- программа,
выполняющая все необходимые для моделирования газа вычисления.

\begin{figure}
	\centering\footnotesize
	\begin{tikzpicture}[block/.style={shape=rectangle,rounded corners,draw=blue!50,fill=blue!20,thick,inner sep=5pt,
							minimum size=1cm,node distance=2cm,text badly centered},
						miniblock/.style={shape=rectangle,draw=blue!50,fill=blue!30,thick,inner sep=5pt,
							minimum size=1cm,node distance=5mm,text badly centered},>=latex',thick]
		\node[block,minimum width=4cm,minimum height=2.9cm] (in) at (2,1.55)			{};
		\node[block,minimum width=4cm,minimum height=2.9cm] (mesh) at (2,-1.55)			{};
		\node[block,minimum width=5.5cm,minimum height=6cm] (solver) at (7.5,0)				{};
		\node[block,minimum width=3.5cm,minimum height=6cm] (out) at (12.75,0)	{};
		\draw [<-] (in.east)+(.75cm-1pt,0) to (in.east);
		\draw [<-] (mesh.east)+(.75cm-1pt,0) to (mesh.east);
		\draw [->] (solver) to (out);

		\node[below] at (in.north) {\textbf{Входные данные}};
		\node[miniblock,text width=3.5cm,inner sep=0pt] at (2,2) {Конфигурационный XML файл};
		\node[miniblock,text width=3.5cm,inner sep=0pt] at (2,.8) {Интерактивная оболочка};

		\node[below] at (mesh.north) {\textbf{Расчетная сетка}};
		\node[miniblock,text width=3.5cm,inner sep=0pt] (rgen) at (2,-1.1) {Генератор сеток прямоугольных};
		\node[miniblock,text width=3.5cm,inner sep=0pt] (gmsh) at (2,-2.3) {GSMH};

		\node[below] at (solver.north) {\textbf{Солвер}};
		\node[miniblock,rotate=90,text width=4cm] (int) at (9.4,0) {Интеграл столкновений};
		\node[miniblock,text width=2.5cm] (rect)  at (6.5,1.5) {RectSolv};
		\node[miniblock,text width=2.5cm] (gpu)   at (6.5,0) {GPUSolv};
		\node[miniblock,text width=2.5cm] (unstr) at (6.5,-1.5) {UnstructSolv};
		\draw [<->] (int.north)+(0,1.5) to (rect.east);
		\draw [<->] (int.north) to (gpu.east);
		\draw [<->] (int.north)+(0,-1.5) to (unstr.east);

		\node[below,rotate=90] (visual) at (out.west) {\textit{Визуализация}};
		\node[above,rotate=90] at (out.east) {\textbf{Выходные данные}};
		\node[miniblock,text width=1.5cm] (gnu)  at (13,2.25) 	{Gnuplot};
		\node[miniblock,text width=1.5cm] (para) at (13,0.75) 	{Paraview};
		\node[miniblock,text width=1.5cm] (bk)   at (13,-0.75) {Bkviewer};
		\node[miniblock,text width=1.5cm] (ncl)  at (13,-2.25) {NCL};
		\draw [->] (visual.east) to[in=180,out=90] (gnu.west);
		\draw [->] (visual.south)+(0,.75) to (para.west);
		\draw [->] (visual.south)+(0,-.75) to (bk.west);
		\draw [->] (visual.west) to[in=180,out=-90] (ncl.west);

		\draw [->,dashed,thin] (rgen.east)+(0,.2) to[out=0,in=135] (rect.north);
		\draw [->,dashed,thin] (rgen.east)+(0,-.2) to[out=0,in=135] (gpu.north);
		\draw [->,dashed,thin] (gmsh.east) to[out=0,in=-135] (unstr.south);

	\end{tikzpicture}
	\caption{Схема проблемно-моделирующей среды}\label{fig:pse}
\end{figure}

Для численного решения кинетического уравнения необходимо оперировать с шестимерной функцией распределения,
что предъявляет высокие требования и к объёму оперативной памяти, и к вычислительной мощности.
Поэтому изначально солверы разрабатывались для функционирования в \textit{многопроцессорной среде}.
В задачи солвера входит численное решение уравнения Больцмана методом конечных объёмов, а также эффективное распараллеливание.
Для этого вся расчётная область делится на области (домены), каждая из которых предоставляется отдельному вычислительному узлу.
Расчёт представляет собой итерационный процесс эволюции функции распределения.
С помощью её интегрирования периодически вычисляются макропараметры, которые записываются в файлы соответствующего формата для дальнейшей визуализации.
Эффективное распараллеливание позволило, с одной стороны, значительно сократить время расчётов (с недель до часов),
с другой "--- обеспечить саму возможность прецизионного расчета на мелких сетках, которые требуют больших объёмов памяти.
На сегодняшний день солверы используют две технологии распараллеливания.
MPI (Message Passing Interface) применяется для вычислений на кластерах из обычных процессоров,
Nvidia CUDA (Compute Unified Device Architecture) "--- для расчетов на видеокартах.
Для моделирования устройств, геометрия которых состоит из прямоугольных областей, используются прямоугольные сетки.
Они используются в солверах RectSolv и GPUSolv, которые для вычислений используют обычный и графический процессор соответственно.
Для решения задач с произвольной геометрией используется солвер UnstructSolv, который оперирует с неструктурированными сетками,
генерируемые пакетом GMSH [].
Уравнение Больцмана решается методом расщепления: по очереди моделируются перенос молекул и их столкновения друг с другом.
Поскольку результат соударений молекул не зависит от пространственной конфигурации, в частности, от координатных сеток,
то все перечисленные солверы используют единый модуль, отвечающий за взятие интеграла столкновений проекционным методом [].
Для анализа полученных результатов применяются различные программные продукты.
Для наглядной визуализации потоков используется пакет NCL (NCAR Command Language) [],
с трёхмерным распределением макропараметров удобно оперировать в среде Paraview [],
которая, кроме того, обладает возможностью обработки больших объёмов данных на кластерных системах.
Для внутреннего использования применяется собственный продукт Bkviewer [], специализированный для оперативного анализа выходных данных.

\subsection{Ввод данных}
Для компьютерного моделирования, прежде всего, пользователь должен сформулировать поставленную задачу на языке, понятном для ПМС.
Для этого используется текстовый конфигурационный файл, который передаётся солверу при его запуске.
Был выбран универсальный xml формат, обеспечивающий одновременно как высокую гибкость задания всевозможных параметров расчёта,
так и ясность, удобную для чтения (или правки) структуру текста.
Такой файл может быть создан вручную, либо с помощью специальной графической интерактивной оболочки.

Конфигурационный файл разбит на множество секций, каждая из которых описывает отдельный объект:
это может быть как применяемая разностная схема или интеграл столкновений, так и моделируемая геометрия или начальные условия задачи.
Каждому объекту соответствует в солвере собственный программный модуль.
Таким образом, задание различных параметров в секции есть выбор и настройка отдельных модулей системы.
 
Все расчеты в системе ведутся в безразмерных переменных.
Это, во-первых, облегчает анализ вычислений,во-вторых, позволяет применить критерий подобия.
Например, если определяющим для физического процесса является число Кнудсена, то результаты вычислений справедливы
как для макроустройств при низком давлении, так и для микроустройств при атмосферном.
Соответственно, начальные условия задаются также в безразмерном виде.

\subsection{Расчётные сетки}
Для решения уравнения Больцмана необходимо моделирование эволюции во времени функции распределения,
которая в общем случае шестимерна по пространственным и скоростным координатам.
Это фазовое пространство покрывается соответствующими конечными сетками.

В скоростном пространстве это просто шар радиусом в несколько тепловых скоростей
(обычно это величина порядка пяти максимальных тепловых скоростей в задаче), равномерно заполненный узлами.
В пространственных координатах могут использоваться различные сетки, покрывающие любые геометрии.
В простом случае, когда геометрия состоит из прямоугольных областей, применяются прямоугольные сетки, генерируемые встроенным модулем.
Построение разностных схем высокого порядка точности значительно проще для таких сеток.
При попытке аппроксимировать искривлённые поверхности прямоугольными ячейками возникает множество трудностей,
поэтому универсальным решением является использование неструктурированных сеток.

Для генерации неструктурированных сеток используется пакет GMSH [] с открытым кодом.
В нём используется алгоритм Delaunay [], а для улучшения качества тетраэдров "--- оптимизатор из открытого пакета Netgen [].
В рамках описываемой ПМС к пространственным сеткам предъявляются следующие требования.
С одной стороны, они должны сгущаться в областях, где движение газа представляет наибольший интерес.
Это позволяет получить хорошую точность в условиях экономии вычислительных ресурсов.
С другой стороны, необходимо высокое качество ячеек (приближенность их к правильным фигурам).
Это связано с особенностями решения уравнения переноса: шаг по времени ограничен минимальной высотой ячейки.

\subsection{Внутреннее устройство солвера}

\begin{figure}
	\centering\footnotesize
	\begin{tikzpicture}[level 1 concept/.append style={sibling angle=60,level distance=4.5cm}, scale=1]
		\path[mindmap,concept color=black,text=white,minimum size=2cm]
		node[concept] {\LARGE\textbf{Солвер}}
		[clockwise from=90]
		child[concept color=green!50!black] {
			node[concept] {Listeners}
			[clockwise from=180]
			child { node[concept] {Starter} }
			child { node[concept] {Stopper} }
			child { node[concept] {Saver} }
			child { node[concept] {Logger} }
		}
		child[concept color=red,minimum size=2.5cm] { node[concept] {\textbf{Интеграл столкновений}} }
		child[concept color=blue] { node[concept] {Параметры газа} }
		child[concept color=orange] { node[concept] {Разбиение на домены} }
		child[concept color=blue] { node[concept] {Сетка \\ Граничные условия} }
		child[concept color=red,minimum size=2.5cm] { node[concept] {\textbf{Уравнение переноса}} };
	\end{tikzpicture}
	\caption{Структурная схема солвера}\label{fig:solver_structure}
\end{figure}

На рис.~\ref{fig:solver_structure} представлено модульное разбиение солвера,
а на рис.~\ref{fig:solver_algorithm} показан общий алгоритм его работы.

Солвер хранит всю информацию в массиве ячеек (\textit{cells}) и границ (\textit{boundaries}).
Набор ячеек считывается из сетки (\textit{grid}). Набор границ --- из геометрии (\textit{geometry}) и граничных условий.
Все ячейки знают про своих соседей, в т.\,ч. про соответствующие им граничные условия.
Параметры газа "--- это информация о молекулярном потенциале, степенях свободы, смесевом составе и т.\,д.

\begin{figure}
	\centering\footnotesize
	\begin{tikzpicture}[node distance=2cm,every path/.style={draw,>=latex',very thick},thick,
						block/.style={rectangle,text width=3cm,text=white,text badly centered,rounded corners,minimum height=4em}]
		\node[block,fill=blue] (init) {Считывание начальных данных};
		\node[block,fill=orange,below of=init] (decomp) {Разбиение расчетной сетки на домены};
		\node[block,fill=green!50!black,below of=decomp] (listeners) {Листенеры};
		\node[below of=listeners] (dummy) {};
		\node[block,fill=green!50!black,node distance=5cm,above left of=listeners] (save) {Сохранение результатов};
		\node[block,fill=green!50!black,node distance=5cm,above right of=listeners] (stop) {Остановка расчёта};

		\node[block,fill=red,left of=dummy, node distance=3cm] (ldiff) {Расчет уравнения переноса для \(\frac\tau2\)};
		\node[block,fill=red,right of=dummy, node distance=3cm] (rdiff) {Расчет уравнения переноса для \(\frac\tau2\)};
		\node[block,fill=red,below of=dummy] (integr) {Расчет интеграла столкновений \\ для \(\tau\)};

		\draw[->] (init) to (decomp);
		\draw[->] (decomp) to (listeners);
		\draw[->] (listeners.east) to [bend left=45] (rdiff.north);
		\draw[<-] (listeners.west) to [bend right=45] (ldiff.north);
		\draw[<-] (integr.east) to [bend right=45] (rdiff.south);
		\draw[->] (integr.west) to [bend left=45] (ldiff.south);
		\draw[->] (listeners) to [bend right=30] node[right,text width=1.2cm,text centered] {если \\ нужно} (stop.south);
		\draw[->] (listeners) to [bend left=30] node[left,text width=1.2cm,text centered] {если \\ нужно} (save.south) ;
	\end{tikzpicture}
	\caption{Алгоритмическая блок-схема солвера}\label{fig:solver_algorithm}
\end{figure}

После считывания начальных данных специализированный модуль (это может собственная подпрограмма или встроенный пакет в GMSH)
разбивает расчётную область на домены (англ. \textit{domain decomposition}), распределяя их между вычислительными узлами.
После этого начинается итерационный процесс в соответствии со схемой расщепления уравнения Больцмана.
Перед каждым временн\textit{ы}м шагом управление передаётся так называемым \textit{листенерам} (\textit{listener}),
каждый из которых отвечает за определённую функцию:
\begin{enumerate}
	\item \textit{Starter} на нулевой итерации задаёт начальные условия.
	\item \textit{Stopper} останавливает итерационный процесс в необхоимый момент времени,
		который может определяться как пользователем, так и на основе текущего распределения макропараметров.
	\item \textit{Saver} периодически сохраняет необходимые данные. В частности, это распределения макропараметров,
		которые в дальнейшем визуализируются с помощью специальных пакетов.
	\item \textit{Logger} соотвественно регистрирует совершенные действия в журнале.
\end{enumerate}
